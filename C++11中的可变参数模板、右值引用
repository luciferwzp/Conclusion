可变参数模板：
C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，
其语法为：在class或typename后面带上省略号"..."。

例如：
Template<class ... T>
void func(T ... args)
{
    cout<<”num is”<<sizeof ...(args)<<endl;

}
func();//args不含任何参数
func(1);//args包含一个int类型的实参
func(1,2.0)//args包含一个int一个double类型的实参
其中T叫做模板参数包，args叫做函数参数包

省略号作用如下：
1）声明一个包含0到任意个模板参数的参数包
2）在模板定义得右边，可以将参数包展成一个个独立的参数

C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，
需要提供一个参数包展开的函数和一个递归终止函数。例如：
#include using namespace std;
// 最终递归函数
void print()

{

    cout << "empty" << endl;


}

// 展开函数
template void print(T head, Args... args)
{
    cout << head << ","; print(args...);

}
int main()
{
    print(1, 2, 3, 4); return 0;

}
参数包Args ...在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数
都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。

右值引用:
C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，
右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生
的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。

C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：
T && a=ReturnRvale();
假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。
基于右值引用可以实现转移语义和完美转发新特性。
移动语义：
对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，
为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。
